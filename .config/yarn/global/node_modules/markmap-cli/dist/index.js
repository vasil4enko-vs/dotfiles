import { readFile, stat, mkdir, writeFile } from "fs/promises";
import { dirname, join, resolve } from "path";
import { fileURLToPath } from "url";
import { Command } from "commander";
import open from "open";
import updateNotifier from "update-notifier";
import { readPackageUp } from "read-package-up";
import { buildCSSItem, buildJSItem, defer } from "markmap-common";
import { Transformer } from "markmap-lib";
export * from "markmap-lib";
import { fillTemplate, baseJsPaths } from "markmap-render";
import { serve } from "@hono/node-server";
import chokidar from "chokidar";
import { EventEmitter } from "events";
import { createReadStream, createWriteStream } from "fs";
import { Hono } from "hono";
import { Readable } from "stream";
import { finished } from "stream/promises";
const TOOLBAR_VERSION = "0.17.2";
const TOOLBAR_CSS = `markmap-toolbar@${TOOLBAR_VERSION}/dist/style.css`;
const TOOLBAR_JS = `markmap-toolbar@${TOOLBAR_VERSION}/dist/index.js`;
const currentDir = dirname(fileURLToPath(import.meta.url));
const ASSETS_PREFIX = "/assets/";
const renderToolbar = () => {
  const { markmap, mm } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute("style", "position:absolute;bottom:20px;right:20px");
  document.body.append(el);
};
function addToolbar(urlBuilder, assets) {
  return {
    styles: [
      ...assets.styles || [],
      ...[TOOLBAR_CSS].map((path) => urlBuilder.getFullUrl(path)).map((path) => buildCSSItem(path))
    ],
    scripts: [
      ...assets.scripts || [],
      ...[TOOLBAR_JS].map((path) => urlBuilder.getFullUrl(path)).map((path) => buildJSItem(path)),
      {
        type: "iife",
        data: {
          fn: (r) => {
            setTimeout(r);
          },
          getParams: () => [renderToolbar]
        }
      }
    ]
  };
}
function localProvider(path) {
  return `${ASSETS_PREFIX}${path}`;
}
function createStreamBody(stream) {
  const body = new ReadableStream({
    start(controller) {
      stream.on("data", (chunk) => {
        controller.enqueue(chunk);
      });
      stream.on("end", () => {
        controller.close();
      });
    },
    cancel() {
      stream.destroy();
    }
  });
  return body;
}
const config = {
  assetsDir: `${currentDir}${ASSETS_PREFIX}`
};
var getMimeType = (filename) => {
  const regexp = /\.([a-zA-Z0-9]+?)$/;
  const match = filename.match(regexp);
  if (!match)
    return;
  let mimeType = mimes[match[1]];
  if (mimeType && mimeType.startsWith("text") || mimeType === "application/json") {
    mimeType += "; charset=utf-8";
  }
  return mimeType;
};
var mimes = {
  aac: "audio/aac",
  abw: "application/x-abiword",
  arc: "application/x-freearc",
  avi: "video/x-msvideo",
  avif: "image/avif",
  av1: "video/av1",
  azw: "application/vnd.amazon.ebook",
  bin: "application/octet-stream",
  bmp: "image/bmp",
  bz: "application/x-bzip",
  bz2: "application/x-bzip2",
  csh: "application/x-csh",
  css: "text/css",
  csv: "text/csv",
  doc: "application/msword",
  docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  eot: "application/vnd.ms-fontobject",
  epub: "application/epub+zip",
  gif: "image/gif",
  gz: "application/gzip",
  htm: "text/html",
  html: "text/html",
  ico: "image/x-icon",
  ics: "text/calendar",
  jar: "application/java-archive",
  jpeg: "image/jpeg",
  jpg: "image/jpeg",
  js: "text/javascript",
  json: "application/json",
  jsonld: "application/ld+json",
  map: "application/json",
  mid: "audio/x-midi",
  midi: "audio/x-midi",
  mjs: "text/javascript",
  mp3: "audio/mpeg",
  mp4: "video/mp4",
  mpeg: "video/mpeg",
  mpkg: "application/vnd.apple.installer+xml",
  odp: "application/vnd.oasis.opendocument.presentation",
  ods: "application/vnd.oasis.opendocument.spreadsheet",
  odt: "application/vnd.oasis.opendocument.text",
  oga: "audio/ogg",
  ogv: "video/ogg",
  ogx: "application/ogg",
  opus: "audio/opus",
  otf: "font/otf",
  pdf: "application/pdf",
  php: "application/php",
  png: "image/png",
  ppt: "application/vnd.ms-powerpoint",
  pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  rtf: "application/rtf",
  sh: "application/x-sh",
  svg: "image/svg+xml",
  swf: "application/x-shockwave-flash",
  tar: "application/x-tar",
  tif: "image/tiff",
  tiff: "image/tiff",
  ts: "video/mp2t",
  ttf: "font/ttf",
  txt: "text/plain",
  vsd: "application/vnd.visio",
  wasm: "application/wasm",
  webm: "video/webm",
  weba: "audio/webm",
  webp: "image/webp",
  woff: "font/woff",
  woff2: "font/woff2",
  xhtml: "application/xhtml+xml",
  xls: "application/vnd.ms-excel",
  xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  xml: "application/xml",
  xul: "application/vnd.mozilla.xul+xml",
  zip: "application/zip",
  "3gp": "video/3gpp",
  "3g2": "video/3gpp2",
  "7z": "application/x-7z-compressed",
  gltf: "model/gltf+json",
  glb: "model/gltf-binary"
};
function sequence(fn) {
  let promise;
  return () => {
    promise || (promise = fn().finally(() => {
      promise = void 0;
    }));
    return promise;
  };
}
class BufferContentProvider {
  constructor() {
    this.deferredSet = /* @__PURE__ */ new Set();
    this.events = new EventEmitter();
    this.ts = 0;
    this.content = "";
    this.line = -1;
    this.events.on("content", () => {
      this.feed({
        ts: this.ts,
        content: this.content
      });
    });
    this.events.on("cursor", () => {
      this.feed({
        line: this.line
      });
    });
  }
  async getUpdate(ts, timeout = 1e4) {
    const deferred = defer();
    this.deferredSet.add(deferred);
    setTimeout(() => {
      this.feed({}, deferred);
    }, timeout);
    if (ts < this.ts) {
      this.feed({ ts: this.ts, content: this.content }, deferred);
    }
    return deferred.promise;
  }
  feed(data, deferred) {
    if (deferred) {
      deferred.resolve(data);
      this.deferredSet.delete(deferred);
    } else {
      for (const d of this.deferredSet) {
        d.resolve(data);
      }
      this.deferredSet.clear();
    }
  }
  setCursor(line) {
    this.line = line;
    this.events.emit("cursor");
  }
  setContent(content) {
    this.ts = Date.now();
    this.content = content;
    this.events.emit("content");
  }
  dispose() {
  }
}
class FileSystemProvider extends BufferContentProvider {
  constructor(fileName) {
    super();
    this.fileName = fileName;
    this.watcher = chokidar.watch(fileName).on(
      "all",
      sequence(() => this.update())
    );
  }
  async update() {
    const content = await readFile(this.fileName, "utf8");
    this.setContent(content);
  }
  dispose() {
    super.dispose();
    this.watcher.close();
  }
}
function startServer(paddingBottom) {
  let ts = 0;
  let root;
  let line;
  let offset = 0;
  const { mm, markmap } = window;
  refresh();
  function refresh() {
    fetch(`/~data?ts=${ts}`).then((res) => res.json()).then((res) => {
      if (res.ts && res.ts > ts && res.result) {
        let frontmatter;
        ({ root, frontmatter, contentLineOffset: offset } = res.result);
        mm.setOptions(markmap.deriveOptions(frontmatter == null ? void 0 : frontmatter.markmap));
        mm.setData(root);
        if (!ts)
          mm.fit();
        ts = res.ts;
        line = -1;
      }
      if (root && res.line != null && line !== res.line) {
        line = res.line;
        const active = findActiveNode();
        if (active)
          mm.ensureView(active, { bottom: paddingBottom });
      }
      setTimeout(refresh, 300);
    });
  }
  function findActiveNode() {
    const lineWithoutFrontmatter = line - offset;
    let best;
    dfs(root);
    return best;
    function dfs(node) {
      var _a, _b, _c;
      const [start, end] = ((_b = (_a = node.payload) == null ? void 0 : _a.lines) == null ? void 0 : _b.split(",").map((s) => +s)) || [];
      if (start >= 0 && start <= lineWithoutFrontmatter && lineWithoutFrontmatter < end) {
        best = node;
      }
      (_c = node.children) == null ? void 0 : _c.forEach(dfs);
    }
  }
}
async function setUpServer(transformer, provider, options) {
  let assets = transformer.getAssets();
  if (options.toolbar)
    assets = addToolbar(transformer.urlBuilder, assets);
  const html = `${fillTemplate(null, assets, {
    urlBuilder: transformer.urlBuilder
  })}<script>(${startServer.toString()})(${options.toolbar ? 60 : 0})<\/script>`;
  const app = new Hono();
  app.get("/", (c) => c.html(html));
  app.get("/~data", async (c) => {
    const update = await provider.getUpdate(+(c.req.query("ts") || 0));
    const result = update.content == null ? null : transformer.transform(update.content || "");
    return c.json({ ts: update.ts, result, line: update.line });
  });
  app.post("/~api", async (c) => {
    var _a;
    const { cmd, args } = await c.req.json();
    await ((_a = provider[cmd]) == null ? void 0 : _a.call(provider, ...args));
    return c.body(null, 204);
  });
  const { assetsDir } = config;
  app.get(`${ASSETS_PREFIX}*`, async (c) => {
    const relpath = c.req.path.slice(ASSETS_PREFIX.length);
    const realpath = join(assetsDir, relpath);
    try {
      const result = await stat(realpath);
      if (!result.isFile())
        throw new Error("File not found");
    } catch {
      return c.body("File not found", 404);
    }
    const stream = createReadStream(realpath);
    const type = getMimeType(relpath);
    if (type)
      c.header("content-type", type);
    return c.body(createStreamBody(stream));
  });
  const server = serve(
    {
      fetch: app.fetch,
      port: options.port
    },
    (info) => {
      const { port } = info;
      console.info(`Listening at http://localhost:${port}`);
      if (options.open)
        open(`http://localhost:${port}`);
    }
  );
  let closing;
  return {
    provider,
    close() {
      if (!closing) {
        closing = new Promise(
          (resolve2, reject) => server.close((err) => {
            if (err)
              reject(err);
            else
              resolve2();
          })
        );
      }
      return closing;
    }
  };
}
async function develop(fileName, options) {
  const transformer = new Transformer();
  transformer.urlBuilder.setProvider("local", localProvider);
  transformer.urlBuilder.provider = "local";
  const provider = fileName ? new FileSystemProvider(fileName) : new BufferContentProvider();
  return setUpServer(transformer, provider, options);
}
const providerName = "local-hook";
async function fetchAssets(assetsDir = config.assetsDir) {
  var _a, _b;
  const transformer = new Transformer();
  const { provider } = transformer.urlBuilder;
  transformer.urlBuilder.setProvider(providerName, localProvider);
  transformer.urlBuilder.provider = providerName;
  let assets = transformer.getAssets();
  assets = addToolbar(transformer.urlBuilder, assets);
  delete transformer.urlBuilder.providers[providerName];
  transformer.urlBuilder.provider = provider;
  const pluginPaths = [
    ...((_a = assets.scripts) == null ? void 0 : _a.map(
      (item) => item.type === "script" && item.data.src || ""
    )) || [],
    ...((_b = assets.styles) == null ? void 0 : _b.map(
      (item) => item.type === "stylesheet" && item.data.href || ""
    )) || []
  ].filter((url) => url.startsWith(ASSETS_PREFIX)).map((url) => url.slice(ASSETS_PREFIX.length));
  const paths = [...baseJsPaths, ...pluginPaths];
  let findingProvider;
  const findProvider = () => {
    findingProvider || (findingProvider = transformer.urlBuilder.getFastestProvider());
    return findingProvider;
  };
  await Promise.all(
    paths.map(
      (path) => downloadAsset(
        resolve(assetsDir, path),
        async () => transformer.urlBuilder.getFullUrl(path, await findProvider())
      )
    )
  );
}
async function downloadAsset(fullPath, resolveUrl) {
  try {
    const result = await stat(fullPath);
    if (result.isFile())
      return;
  } catch {
  }
  const url = await resolveUrl();
  const res = await fetch(url);
  if (!res.ok || !res.body)
    throw new Error(`Failed to download: ${url}`);
  await mkdir(dirname(fullPath), { recursive: true });
  await finished(
    Readable.fromWeb(res.body).pipe(
      createWriteStream(fullPath)
    )
  );
}
async function loadFile(path) {
  if (path.startsWith(ASSETS_PREFIX)) {
    const relpath = path.slice(ASSETS_PREFIX.length);
    return readFile(resolve(config.assetsDir, relpath), "utf8");
  }
  const res = await fetch(path);
  if (!res.ok)
    throw res;
  return res.text();
}
async function inlineAssets(assets) {
  const [scripts, styles] = await Promise.all([
    Promise.all(
      (assets.scripts || []).map(
        async (item) => item.type === "script" && item.data.src ? {
          type: "script",
          data: {
            textContent: await loadFile(item.data.src)
          }
        } : item
      )
    ),
    Promise.all(
      (assets.styles || []).map(
        async (item) => item.type === "stylesheet" ? {
          type: "style",
          data: await loadFile(item.data.href)
        } : item
      )
    )
  ]);
  return {
    scripts,
    styles
  };
}
async function createMarkmap(options) {
  const transformer = new Transformer();
  if (options.offline) {
    transformer.urlBuilder.setProvider("local", localProvider);
    transformer.urlBuilder.provider = "local";
  } else {
    try {
      await transformer.urlBuilder.findFastestProvider();
    } catch {
    }
  }
  const { root, features, frontmatter } = transformer.transform(
    options.content || ""
  );
  let assets = transformer.getUsedAssets(features);
  assets = {
    ...assets,
    scripts: [
      ...baseJsPaths.map((path) => transformer.urlBuilder.getFullUrl(path)).map((path) => buildJSItem(path)),
      ...assets.scripts || []
    ]
  };
  if (options.toolbar) {
    assets = addToolbar(transformer.urlBuilder, assets);
  }
  if (options.offline) {
    assets = await inlineAssets(assets);
  }
  const html = fillTemplate(root, assets, {
    baseJs: [],
    jsonOptions: frontmatter == null ? void 0 : frontmatter.markmap,
    urlBuilder: transformer.urlBuilder
  });
  const output = options.output || "markmap.html";
  await writeFile(output, html, "utf8");
  if (options.open)
    open(output);
}
async function main() {
  var _a;
  const pkg = (_a = await readPackageUp({
    cwd: fileURLToPath(import.meta.url)
  })) == null ? void 0 : _a.packageJson;
  if (!pkg)
    throw new Error("package.json not found");
  const notifier = updateNotifier({ pkg });
  notifier.notify();
  const program = new Command();
  program.version(pkg.version).description("Create a markmap from a Markdown input file").arguments("<input>").option("--no-open", "do not open the output file after generation").option("--no-toolbar", "do not show toolbar").option("-o, --output <output>", "specify filename of the output HTML").option(
    "--offline",
    "Inline all assets to allow the generated HTML to work offline"
  ).option(
    "-w, --watch",
    "watch the input file and update output on the fly, note that this feature is for development only"
  ).action(async (input, cmd) => {
    let { offline } = cmd;
    if (cmd.watch)
      offline = true;
    if (offline)
      await fetchAssets();
    const content = await readFile(input, "utf8");
    const output = cmd.output || `${input.replace(/\.\w*$/, "")}.html`;
    if (cmd.watch) {
      await develop(input, {
        open: cmd.open,
        toolbar: cmd.toolbar,
        offline
      });
    } else {
      await createMarkmap({
        content,
        output,
        open: cmd.open,
        toolbar: cmd.toolbar,
        offline
      });
    }
  });
  program.parse(process.argv);
}
export {
  config,
  createMarkmap,
  develop,
  fetchAssets,
  main
};
